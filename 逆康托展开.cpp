//在给出61可以算出起排列组合为34152。由上述的计算过程可以容易的逆推回来，具体过程如下：
//用 61 / 4! = 2余13，等于2,说明比第一位小的数有2个，所以首位为3。
//拿 13 / 3! = 2余1，说明在剩下的中，小于第二位的数有2个，但是所以第二位为4。
//拿 1 / 2! = 0余1，说明在剩下的中，小于第三位的数，所以第三位为1。
//拿 1 / 1! = 1余0，说明在剩下的中，小于第四位的数有1个，所以第四位为5。
//最后一位自然就是剩下的数2。
//通过以上分析，所求排列组合为 34152。
//但 memset 是对较大的数组或结构体进行清零初始化的最快方法，因为它是直接对内存进行操作的。
//memset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化，无法将变量初始化为程序中需要的数据。用memset初始化完后，后面程序中再向该内存空间中存放需要的数据。

//memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。
#include<stdio.h>
int a[10];
void jc();
int get(int x,int y,int b[]);
int main()
{
	int x,y,i,b[10];
	scanf("%d",&x);
	scanf("%d",&y);
	get(x,y,b);
	for(i=0;i<x;i++)
	{
		printf("%d",b[i]);
	}
 } 
 int get(int x,int y,int b[])
 {
 	int k=y-1,q,i,j;
 	jc();
 	for(i=0;i<x;i++)
 	{
 		q=k/a[x-1-i];//相除 
 		k=k%a[x-1-i];//求余 
 		b[i]=q-1;
 		for(j=0;j<i;j++)
 		{
 			if(b[i]==b[j])
 			{
 				b[i]++;
			 }
		 }
	 }
 }
 void jc()
 {
 	int i;
 	a[0]=1;
 	int n=100;
 	for(i=1;i<n;i++)
 	{
 		a[i]=a[i-1]*i;
	 }
 }
